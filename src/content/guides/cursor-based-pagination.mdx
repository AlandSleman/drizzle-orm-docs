---
title: SQL Cursor-based pagination
---

import Section from "@mdx/Section.astro";

This guide demonstrates benefits and drawbacks of `cursor-based` pagination and how to implement it in Drizzle.

There are two main benefits of `cursor-based` pagination: It is consistent query result, there are no skipped or duplicated rows due to insert or delete operations and it is more efficient than `limit/offset` pagination because it does not need to scan previous rows and skip them to get to the next page.

The main idea of this pagination is to use cursor as a pointer to a specific row in a dataset to indicate where the last page left off. To navigate to new pages, the client sends to the server the cursor of the last row of the current page, so the server can return rows after that cursor. To achieve this the column that we use as a cursor should be unique and sequential so that we can order by that column and correctly perform the cursor comparison.

Below, there are example of schema definition and the corresponding database data:

<Section>
```ts copy
import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  firstName: text('first_name').notNull(),
  lastName: text('last_name').notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});
```

```plaintext
+----+------------+------------+----------------------------+
| id | first_name | last_name  |         created_at         |
+----+------------+------------+----------------------------+
|  1 | Alice      | Johnson    | 2024-03-08 12:23:55.251797 |
+----+------------+------------+----------------------------+
|  2 | Alex       | Smith      | 2024-03-08 12:25:55.182    |
+----+------------+------------+----------------------------+
|  3 | Aaron      | Williams   | 2024-03-08 12:28:55.182    |
+----+------------+------------+----------------------------+
|  4 | Brian      | Brown      | 2024-03-08 12:34:55.182    |
+----+------------+------------+----------------------------+
|  5 | Beth       | Davis      | 2024-03-08 12:40:55.182    |
+----+------------+------------+----------------------------+
|  6 | Charlie    | Miller     | 2024-03-08 13:04:55.182    |
+----+------------+------------+----------------------------+
|  7 | Clara      | Wilson     | 2024-03-08 13:22:55.182    |
+----+------------+------------+----------------------------+
|  8 | David      | Moore      | 2024-03-08 13:34:55.182    |
+----+------------+------------+----------------------------+
|  9 | Aaron      | Anderson   | 2024-03-08 12:40:33.677235 |
+----+------------+------------+----------------------------+
```
</Section>

The easiest way to implement `cursor-based` pagination is to use primary key column which is monotonically orderable (e.g. serial) as a cursor.

This is how you can implement it using [core queries](/docs/select):

<Section>
```ts copy {10,11,12}
import { asc, gt } from 'drizzle-orm';
import { users } from './schema';

const db = drizzle(...);

const getUsers = async (cursor?: number, limit = 3) => {
  await db
    .select()
    .from(users)
    .where(cursor ? gt(users.id, cursor) : undefined) // if cursor is provided, get rows after it
    .limit(limit) // the number of rows to return (page_size)
    .orderBy(asc(users.id)); // ordering
};

// navigates to the first page
await getUsers();
```

```ts
// first page, 1-3 rows returned
[
  {
    id: 1,
    firstName: 'Alice',
    lastName: 'Johnson',
    createdAt: 2024-03-08T12:23:55.251Z
  },
  {
    id: 2,
    firstName: 'Alex',
    lastName: 'Smith',
    createdAt: 2024-03-08T12:25:55.182Z
  },
  {
    id: 3,
    firstName: 'Aaron',
    lastName: 'Williams',
    createdAt: 2024-03-08T12:28:55.182Z
  }
]
```

```ts {2}
// navigates to the next page, pass the cursor of the last row of the first page (id)
await getUsers(3);
```

```sql
select * from users order by id asc limit 3;
```

```ts
// next page, 4-6 rows returned
[
  {
    id: 4,
    firstName: 'Brian',
    lastName: 'Brown',
    createdAt: 2024-03-08T12:34:55.182Z
  },
  {
    id: 5,
    firstName: 'Beth',
    lastName: 'Davis',
    createdAt: 2024-03-08T12:40:55.182Z
  },
  {
    id: 6,
    firstName: 'Charlie',
    lastName: 'Miller',
    createdAt: 2024-03-08T13:04:55.182Z
  }
]
```
</Section>

If you have to sort by non-unique and non-sequential column, you can use multiple columns as a cursor. In this example, our cursor is a combination of `id` and `firstName` columns. Since we add more columns to the sort order, we'll need to add more filters to the `where` clause for the cursor comparison.

Also we have to create indices for the columns that we use as the cursor to make the query efficient.

<Section>
```ts copy {7,8}
import { index, ...imports } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
// columns declaration
},
(t) => ({
  firstNameIndex: index('first_name_index').on(t.firstName).asc(),
  firstNameAndIdIndex: index('first_name_and_id_index').on(t.firstName, t.id).asc(),
}),
);
```

```sql
-- As of now drizzle-kit only supports index name and on() param, so you have to add order manually
CREATE INDEX IF NOT EXISTS "first_name_index" ON "users" ("first_name" ASC);
CREATE INDEX IF NOT EXISTS "first_name_and_id_index" ON "users" ("first_name" ASC,"id" ASC);
```
</Section>

If cursor is provided, we get rows after it based on the `firstName` and if the `firstName` is the same, we also use the `id` to compare.

<Section>
```ts copy {13,14,15,16,17,18,19,20,21,22}
import { and, asc, eq, gt, or } from 'drizzle-orm';

const getUsers = async (
  cursor?: {
    id: number;
    firstName: string;
  },
  limit = 3,
) => {
  await db
    .select()
    .from(users)
    .where(
      cursor
        ? or(
            gt(users.firstName, cursor.firstName),
            and(eq(users.firstName, cursor.firstName), gt(users.id, cursor.id)),
          )
        : undefined,
    )
    .limit(limit)
    .orderBy(asc(users.firstName), asc(users.id));
};

await getUsers();
```


```ts
// first page
[
  {
    id: 3,
    firstName: 'Aaron',
    lastName: 'Williams',
    createdAt: 2024-03-08T12:28:55.182Z
  },
  {
    id: 9,
    firstName: 'Aaron',
    lastName: 'Anderson',
    createdAt: 2024-03-08T12:40:33.677Z
  },
  {
    id: 2,
    firstName: 'Alex',
    lastName: 'Smith',
    createdAt: 2024-03-08T12:25:55.182Z
  }
]
```

```ts copy {3,4}
// pass the cursor of the last row of the first page (id & firstName)
await getUsers({
  id: 2,
  firstName: 'Alex',
});
```

```sql
select * from users
  where (first_name > 'Alex' or (first_name = 'Alex' and id > 2))
  order by first_name asc, id asc limit 3;
```

```ts
// next page
[
  {
    id: 1,
    firstName: 'Alice',
    lastName: 'Johnson',
    createdAt: 2024-03-08T12:23:55.251Z
  },
  {
    id: 5,
    firstName: 'Beth',
    lastName: 'Davis',
    createdAt: 2024-03-08T12:40:55.182Z
  },
  {
    id: 4,
    firstName: 'Brian',
    lastName: 'Brown',
    createdAt: 2024-03-08T12:34:55.182Z
  }
]
```
</Section>

In practice, it is not always possible to use a serial primary key. You might be using a primary key, which is not sequential (e.g. UUID).

<Section>
```ts copy {4}
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  firstName: text('first_name').notNull(),
  lastName: text('last_name').notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});
```

```plaintext
+--------------------------------------+------------+-----------+----------------------------+
| id                                   | first_name | last_name | created_at                 |
+--------------------------------------+------------+-----------+----------------------------+
| 49fdfffd-0b20-4196-9a94-3f6708b81c5b | Alice      | Johnson   | 2024-03-09 17:54:36.48435  |
+--------------------------------------+------------+-----------+----------------------------+
| 9dd83607-94eb-4db7-b8d6-64a3db32e402 | Alex       | Smith     | 2024-03-09 17:56:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 66ed00a4-c020-4dfd-a1ca-5d2e4e54d174 | Aaron      | Williams  | 2024-03-09 17:59:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| a538a621-08c1-4ff8-b2a5-345ee02b9415 | Brian      | Brown     | 2024-03-09 18:05:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 8165012c-e455-4dca-960f-b464ef8fe85d | Beth       | Davis     | 2024-03-09 18:11:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 8821cbdb-55cd-47c2-8ce6-4df2ab21463b | Charlie    | Miller    | 2024-03-09 18:35:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 55b35009-1cd0-4acb-835c-b30877e02ee1 | Clara      | Wilson    | 2024-03-09 18:53:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 291ddd6a-88fe-4f9d-82d4-83d3b1784185 | David      | Moore     | 2024-03-09 19:05:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
| 5109cd12-df2b-416c-94d8-c7ecfacda476 | Aaron      | Anderson  | 2024-03-09 19:08:36.406    |
+--------------------------------------+------------+-----------+----------------------------+
```
</Section>

It is impossible to implement consistent pagination with only this column as a cursor because it is not orderable.
In this case it is necessary to add another column that is more reliable to cursor. A good practice is too use sequential column such as `created_at` which keep track of the time when the row was created. So we use multiple cursor where `created_at` is sequential and `id` is unique.

Again you have to create indices for the columns that we use as the cursor to make the query efficient.

<Section>
```ts copy {11,12,13,14,15,16,17,18,19,20}
const getUsers = async (
  cursor?: {
    id: string;
    createdAt: Date;
  },
  limit = 3,
) => {
  await db
    .select()
    .from(users)
    .where(
      cursor
        ? or(
            gt(users.createdAt, cursor.createdAt),
            and(eq(users.createdAt, cursor.createdAt), gt(users.id, cursor.id)),
          )
        : undefined,
    )
    .limit(limit)
    .orderBy(asc(users.createdAt), asc(users.id));
};

await getUsers();
```

```ts
// first page
[
  {
    id: '49fdfffd-0b20-4196-9a94-3f6708b81c5b',
    firstName: 'Alice',
    lastName: 'Johnson',
    createdAt: 2024-03-09T17:54:36.484Z
  },
  {
    id: '9dd83607-94eb-4db7-b8d6-64a3db32e402',
    firstName: 'Alex',
    lastName: 'Smith',
    createdAt: 2024-03-09T17:56:36.406Z
  },
  {
    id: '66ed00a4-c020-4dfd-a1ca-5d2e4e54d174',
    firstName: 'Aaron',
    lastName: 'Williams',
    createdAt: 2024-03-09T17:59:36.406Z
  }
]
```

```ts copy {2,3}
await getUsers({
  id: '66ed00a4-c020-4dfd-a1ca-5d2e4e54d174',
  createdAt: new Date('2024-03-09T17:59:36.406Z'),
});
```

```ts
// next page
[
  {
    id: 'a538a621-08c1-4ff8-b2a5-345ee02b9415',
    firstName: 'Brian',
    lastName: 'Brown',
    createdAt: 2024-03-09T18:05:36.406Z
  },
  {
    id: '8165012c-e455-4dca-960f-b464ef8fe85d',
    firstName: 'Beth',
    lastName: 'Davis',
    createdAt: 2024-03-09T18:11:36.406Z
  },
  {
    id: '8821cbdb-55cd-47c2-8ce6-4df2ab21463b',
    firstName: 'Charlie',
    lastName: 'Miller',
    createdAt: 2024-03-09T18:35:36.406Z
  }
]
```
</Section>

Drizzle has useful relational queries API, that lets you easily implement `cursor-based` pagination in queries:

```ts copy {13,14,15,16,17,18,19,20,21}
import * as schema from './db/schema';

const db = drizzle(..., { schema });

const getUsers = async (
  cursor?: {
    id: number;
    firstName: string;
  },
  limit = 3,
) => {
  await db.query.users.findMany({
    orderBy: (users, { asc }) => [asc(users.firstName), asc(users.id)],
    limit,
    where: (users, { gt, eq, and, or }) =>
      cursor
        ? or(
            gt(users.firstName, cursor.firstName),
            and(eq(users.firstName, cursor.firstName), gt(users.id, cursor.id)),
          )
        : undefined,
  });
};

await getUsers();
// next page
await getUsers({
  id: 2,
  firstName: 'Alex',
});
```

One of drawbacks of `cursor-based` pagination is that it is not possible to navigate to a specific page directly. You have to navigate to the first page and then navigate to the next page by passing the cursor of the last row of the previous page.

Another drawback of this pagination is that it is more complicated to implement it than `limit/offset` pagination. You always have to think carefully about constructing the cursor, as well as the ordering and filters to ensure consistent pagination. Furthermore, it is necessary to create indices for the columns used as the cursor to make the query efficient.
