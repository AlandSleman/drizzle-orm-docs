---
title: Count rows
---
import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import CodeTabs from '@components/markdown/CodeTabs.astro';
import CodeTab from '@components/markdown/CodeTab.astro';

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- Get started with [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql), [SQLite](/docs/get-started-sqlite)
- [Select statement](/docs/select)
- [Filters](/docs/operators)
- [sql operator](/docs/sql)
- [Joins](/docs/joins)
- [Aggregations](/docs/select#aggregations)
- [Aggregation helpers](/docs/select#aggregations-helpers)
</Prerequisites>

To count all rows in table you can use `count()` function or `sql` operator like below:

<Section>
```ts copy {5,8}
import { count, sql } from 'drizzle-orm';

const db = drizzle(...);

await db.select({ count: count(products.id) }).from(products);

// Under the hood, the count() function casts its result to a number at runtime.
await db.select({ count: sql`count(${products.id})`.mapWith(Number) }).from(products);

type Response = {
  count: number;
}[];
```

```sql
select count("id") from products;
```
</Section>

Drizzle has simple and flexible API, which lets you create your custom solutions. In PostgreSQL and MySQL `count()` function returns bigint, which is interpreted as string by driver, so it should be casted to integer. This is how you can do it:

<Section>
```ts copy {6,9}
import { AnyColumn, sql } from 'drizzle-orm';

const db = drizzle(...);

const customCount = (column: AnyColumn) => {
  return sql<number>`cast(count(${column}) as integer)`;
};

await db.select({ count: customCount(products.id) }).from(products);

type Response = {
  count: number;
}[];
```

```sql
select cast(count("id") as integer) from products;
```
</Section>

In SQLite, casting isn't necessary as `count()` returns integer.

<Section>
```ts copy {5}
import { sql } from 'drizzle-orm';

const db = drizzle(...);

await db.select({ count: sql<number>`count(${products.id})` }).from(products);

type Response = {
  count: number;
}[];
```

```sql
select count("id") from products;
```
</Section>

To count rows that match a condition you can use `count()` function and `.where()` method:

<Section>
```ts copy {6,8}
import { count, gt } from 'drizzle-orm';

const db = drizzle(...);

await db
  .select({ count: count(products.id) })
  .from(products)
  .where(gt(products.price, 100));
```

```sql
select count("id") from products where price > 100
```
</Section>

This is how you can use `count()` function with joins and aggregations:

<CodeTabs items={["index.ts", "schema.ts"]}>
	<CodeTab>
    ```ts copy {10,13,14,15}
    import { count, eq } from 'drizzle-orm';
    import { countries, cities } from './schema';

    const db = drizzle(...);

    // Count cities in each country
    await db
      .select({
        country: countries.name,
        citiesCount: count(cities.id),
      })
      .from(countries)
      .leftJoin(cities, eq(countries.id, cities.countryId))
      .groupBy(countries.id)
      .orderBy(countries.name);
    ```

    ```sql
    select countries.name, count("cities"."id") from countries
      left join cities on countries.id = cities.country_id
      group by countries.id
      order by countries.name;
    ```
  </CodeTab>
  ```ts
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const countries = pgTable('countries', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
  });

  export const cities = pgTable('cities', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    countryId: integer('country_id')
      .notNull()
      .references(() => countries.id),
  });
  ```
</CodeTabs>
